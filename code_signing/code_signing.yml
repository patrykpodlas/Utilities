# Include all of the repositories which you want this pipeline to scan for files to sign, make sure you also check them out in the jobs step checkout.
resources:
  repositories:
    - repository: Utilities
      type: github
      endpoint: patrykpodlas
      name: patrykpodlas/Utilities
    - repository: Azure
      type: github
      endpoint: patrykpodlas
      name: patrykpodlas/Azure

  webhooks:
    - webhook: MyTrigger
      connection: Trigger-Utilities
      filters:
        - path: action
          value: closed

trigger:
  branches:
    include:
    - main # Trigger only on the main branch.
    - feature-shacomparison
  paths:
    include:
    - '*' # Include all files within the repository.

pr: none # Do not trigger on PR, this is taken care of by the CI trigger.

variables:
  - group: Code Signing # This must include all the secrets, do not store the certificate in secure files, instead link the variable group to the Azure key vault and retrieve the secrets as well as the certificate from there.

jobs:
  - job: code_signing
    pool:
      name: vSphere # For this pipeline, this agent can be an online agent as it does not connect to any on-premises resources.
    steps:
      - checkout: self
      - checkout: Azure
      - task: AzureCLI@2 # Connects to the storage account and retrieves the existing signed files in the container, exports the list to a variable which is then used in the next task.
        displayName: Retrieve a list of existing signed files
        inputs:
          azureSubscription: 'Code-Signing'
          scriptType: 'ps'
          scriptLocation: 'inlineScript'
          workingDirectory: '$(Build.StagingDirectory)'
          addSpnToEnvironment: true
          inlineScript: |
            Write-Output "--- Logging into storage account, to retrieve a list of already signed files."
            $SecurePassword = ConvertTo-SecureString -String $(service-principal-secret) -AsPlainText -Force
            $PSCredential = New-Object System.Management.Automation.PSCredential($env:ServicePrincipalID, $SecurePassword)
            Connect-AzAccount -ServicePrincipal -Credential $PSCredential -Tenant $env:TenantID
            Write-Output "--- Logged into Azure."
            Write-Output "--- Searching for existing signed files."
            $Context = $(Get-AzStorageAccount -ResourceGroupName $(storage-account-resource-group-name) -Name $(storage-account)).Context
            # Getting list of files in the blob, the object will also contain the existing SHA256 metadata.
            $ExistingFiles = Get-AzStorageBlob -Container $(destination-container) -Context $Context |
            Select-Object -Property @{Name = "Name"; Expression = { $_.Name.Split('/')[-1] } }, `
                                    @{Name = "SHA256"; Expression = { $_.BlobClient.GetProperties().Value.Metadata.SHA256 } }

            Write-Output "--- Existing files in the storage account:"
            Write-Output $ExistingFiles

            $ExistingFilesJson = ($ExistingFiles | ConvertTo-Json -Compress)
            Write-Host "##vso[task.setvariable variable=ExistingFilesJson;]$ExistingFilesJson"

      - task: PowerShell@2 # Scans the files in each repository, and then signs them. Note: Set-AuthenticodeSignature is not supported on non-Windows endpoints.
        displayName: Signing files in each repository
        inputs:
          targetType: 'inline'
          script: |
            $ExistingFiles = '$(ExistingFilesJson)' | ConvertFrom-Json
            $Directories = Get-ChildItem -Path "$(Agent.BuildDirectory)/s" -Directory | Select-Object -ExpandProperty Name
            Write-Output "--- Retrieving a list of files to be signed."
            $Files = @()
            foreach($Directory in $Directories){
                Write-Output "--- Getting a list of files from $Directory repository to scan."
                $Files += Get-ChildItem -Path "$(Agent.BuildDirectory)/s/$Directory" -Include '*.ps1' -Recurse
            }

            $Files = $Files | ForEach-Object {
                $FileContent = Get-Content $_ -ErrorAction Ignore
                # Check if the file has the #sign-me tag
                if ($FileContent | Select-String -Pattern '#sign-me') {
                    # If it does, check if it's already signed, we do not want to sign already signed script.
                    $HasBeginBlock = $FileContent | Select-String -Pattern '# SIG # Begin signature block'
                    $HasEndBlock = $FileContent | Select-String -Pattern '# SIG # End signature block'
                    # If it doesn't have the signature blocks then calculate the hash of the file to be signed
                    if (-not ($HasBeginBlock -and $HasEndBlock)) {
                        $Hash = (Get-FileHash -Path $_.FullName -Algorithm SHA256).Hash
                        # Add the hash to the object property
                        $_ | Add-Member -NotePropertyName "SHA256" -NotePropertyValue $Hash -PassThru | ForEach-Object {
                            # Compare the hash of the file to the hash of the file inside the storage account, the hash in the storage account will have a value of pre-signed script.
                            $FileName = $_.Name
                            $ExistingFile = $ExistingFiles | Where-Object { $_.Name -eq $FileName }
                            if ($File.SHA256 -and $ExistingFile.SHA256 -eq $File.SHA256) {
                                Write-Host "File '$FileName' already exists with the same hash in the storage account."
                            } else {$_}
                        }
                    }
                }
            }

            # Output the list of files and their hash.
            Write-Output $Files | Select-Object Name, SHA256

            $FilteredFiles = $Files #| Where-Object {$ExistingFiles.Name -notcontains $_.Name}

            if ($FilteredFiles) {
                Write-Output "--- Creating the code signing certificate from Azure Key Vault."
                New-Item "$(Build.StagingDirectory)\code_signing_certificate.pfx" -Value $(code-signing-certificate) | Out-Null
                if (Get-Item -Path "$(Build.StagingDirectory)\code_signing_certificate.pfx") {
                    Write-Output "--- Successfully created the code signing certificate."
                }

                Write-Output "--- Importing the code signing certificate."
                $Certificate = Import-PfxCertificate -CertStoreLocation Cert:\CurrentUser\My -FilePath "$(Build.StagingDirectory)\code_signing_certificate.pfx"

                Write-Output "--- Files to sign:"
                foreach ($File in $FilteredFiles) {
                    Write-Output $File.Name
                }
                foreach ($File in $FilteredFiles) {
                    Write-Output "--- Copying: $($File.Name) to $(Build.StagingDirectory) and signing."
                    $CopiedFile = Copy-Item -Path $File -Destination $(Build.StagingDirectory) -PassThru | Select-Object -ExpandProperty FullName
                    Write-Output "$($File.Name): $(Set-AuthenticodeSignature -Certificate $Certificate -FilePath $CopiedFile -TimestampServer 'http://timestamp.sectigo.com' | Select-Object -ExpandProperty StatusMessage)"
                }

                Write-Output "--- Finished signing all the files."

                Write-Output "--- Removing the certificate from the certificate store."
                Write-Output "--- Looking for certificate with thumbprint: $($Certificate.Thumbprint)."
                Get-Item -Path Cert:\CurrentUser\My\$Certificate.Thumbprint | Remove-Item
                Write-Output "--- Certificate removed from store."

                Write-Output "--- Removing the certificate from the staging directory."
                Get-Item -Path $(Build.StagingDirectory)\code_signing_certificate.pfx | Remove-Item
                Write-Output "--- Certificate removed from the staging directory."

                Write-Host "##vso[task.setvariable variable=Success]true"

            } elseif (!$FilteredFiles) {
                Write-Output "--- Nothing to sign, or the files already exist in the storage account."
                Write-Host "##vso[task.setvariable variable=Success]false"
            }

      - task: AzureFileCopy@5 # Copies the signed files to the storage account container, the blob prefix is powershell.
        displayName: Copying signed files to Azure Blob
        inputs:
          Destination: 'AzureBlob'
          azureSubscription: 'Code-Signing'
          SourcePath: $(Build.StagingDirectory)\*
          storage: $(storage-account)
          ContainerName: $(destination-container)
          BlobPrefix: 'powershell'
        condition: and(succeeded(), eq(variables['Success'], 'true'))

      - task: AzureCLI@2
        displayName: Update the blobs with the SHA256 hashes
        inputs:
          azureSubscription: 'Code-Signing'
          scriptType: 'ps'
          scriptLocation: 'inlineScript'
          workingDirectory: '$(Build.StagingDirectory)'
          addSpnToEnvironment: true
          inlineScript: |
            Write-Output "--- Logging into storage account, to retrieve a list of already signed files."
            $SecurePassword = ConvertTo-SecureString -String $(service-principal-secret) -AsPlainText -Force
            $PSCredential = New-Object System.Management.Automation.PSCredential($env:ServicePrincipalID, $SecurePassword)
            Connect-AzAccount -ServicePrincipal -Credential $PSCredential -Tenant $env:TenantID
            Write-Output "--- Logged into Azure."

            $ExistingFiles = '$(ExistingFilesJson)' | ConvertFrom-Json
            $DestinationContainer = "$(destination-container)"
            $BlobPrefix = "powershell"
            $Context = $(Get-AzStorageAccount -ResourceGroupName $(storage-account-resource-group-name) -Name $(storage-account)).Context

            $ExistingFiles | ForEach-Object {
                $BlobName = "{0}/{1}" -f $BlobPrefix, $_.Name
                $Blob = Get-AzStorageBlob -Container $DestinationContainer -Blob $BlobName -Context $Context

                if ($Blob -ne $null) {
                    $Blob.Metadata["SHA256"] = $_.SHA256
                    $Blob | Set-AzStorageBlobMetadata -Context $Context
                    Write-Output "Set metadata for blob '$BlobName' with SHA256 hash: $($_.SHA256)"
                }
            }

      - task: DeleteFiles@1 # Cleaning up the stating directory.
        displayName: Deleting files in staging directory
        inputs:
          SourceFolder: '$(Build.StagingDirectory)'
          Contents: '**'
          Recursive: true
        condition: and(succeeded(), eq(variables['Success'], 'true'))